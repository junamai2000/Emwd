#!/usr/bin/perl -w
# vim:set noexpandtab sts=0 ts=4 sw=4 ft=perl fenc=utf-8 ff=unix:
require 5.005;

use Getopt::Long;
use Parse::Lex;
use File::Basename qw/basename dirname/;

my $opt_file = 0;
my $opt_dir = 0;
my $opt_inc = 0;
GetOptions(
	'file=s' => \$opt_file,
	'dir=s' => \$opt_dir,
	'inc=s' => \$opt_inc,
);

sub get_base_name($)
{
	my $file_name = shift;
	my $basename = $file_name;
	$basename =~ s/(.*)\..*?$/$1/;
	if ($basename eq '')
	{
		$basename = $file_name;
	}
	return $basename;
}

my @token = (
	# Header mode
	'INITIAL:HEADER_TAG', '<\?header', sub {
		$lexer->start('in_header'); 
		$_[1] 
	},
	'in_header:HEADER_CLOSE_TAG', '\?>', sub { 
		$lexer->end('in_header');
		$_[1] 
	},
	'in_header:H_NEWLINE', '\n', sub {
		$_[1] 
	},
	'in_header:H_STRING', '.*', sub {
		$_[1] 
	},

	# Init mode
	'INITIAL:INIT_TAG', '<\?init', sub { 
		$lexer->start('in_init');
		$_[1] 
	},
	'in_init:INIT_CLOSE_TAG', '\?>', sub { 
		$lexer->end('in_init');
		$_[1] 
	},
	'in_init:I_NEWLINE', '\n', sub {
		$_[1] 
	},
	'in_init:I_STRING', '.*', sub {
		$_[1] 
	},

	# CPP mode
	'INITIAL:CPP_TAG', '<\?c\+\+', sub { 
		$lexer->start('in_cpp');
		$_[1] 
	},
	'in_cpp:CPP_CLOSE_TAG', '\?>', sub { 
		$lexer->end('in_cpp');
		$_[1] 
	},
	'in_cpp:C_NEWLINE', '\n', sub {
		$_[1] 
	},
	'in_cpp:C_STRING', '.*', sub {
		$_[1] 
	},

	# Echo mode
	'INITIAL:ECHO_TAG', '<\?=', sub { 
		$lexer->start('in_echo') ;
		$_[1] 
	},
	'in_echo:ECHO_CLOSE_TAG', '\?>', sub { 
		$lexer->end('in_echo');
		$_[1] 
	},
	'in_echo:E_NEWLINE', '\n', sub {
		$_[1] 
	},

	'in_echo:E_STRING', '.*', sub {
		$_[1] 
	},
	
	# Normal mode
	'NEWLINE', '\n', sub {
		$_[1] 
	},
	'STRING', '.*', sub {
		$_[1] 
	},
);

my @all_files = glob "$opt_dir/*.tpl";
my $memberFunction = "";

foreach my $file (@all_files)
{
	my $tmp = basename $file;
	my $basename = get_base_name($tmp);
	open my $fh, '<', $file or die $! ." : ". $file;

	#Parse::Lex->trace;  # Class method
	Parse::Lex->exclusive('in_header', 'in_init', 'in_cpp', 'in_echo');
	$lexer = Parse::Lex->new(@token);
	$lexer->from($fh);

	my $header = "";
	my $init = ""; 
	my $cpp = "";
	my $source = "";

	TOKEN:while (1)
	{
		$token = $lexer->next;
		if (not $lexer->eoi) {
			#print "Line $.\t";
			#print "Type: ", $token->name, "\t";
			#print "Content:->", $token->text, "<-\n";
			if ($token->name eq "H_STRING"){ 
				$header .= $token->text;
			} elsif ($token->name eq "I_STRING") {
				$init .= $token->text;
				#print $token->text;
			} elsif ($token->name eq  "C_STRING") {
				$source .= $token->text ."\n";
				#print $token->text;
			} elsif ($token->name eq "E_STRING") {
				#$source .= 'output->append("'. $token->text .'")';
			} elsif ($token->name eq "STRING") {
				$source .= 'output->append("'. $token->text .'");'."\n";
			}
		} else {
			last TOKEN;
		}
	}

	close $fh;

	my $generatedSource = <<"EOS";
// vim:set noexpandtab sts=0 ts=4 sw=4 ft=cpp fenc=utf-8 ff=unix:
//==========================================================
// DO NOT EDIT. THIS FILE IS GENERATED BY Kozaiku.pl
//==========================================================
#include "Kozaiku_Template_Autogen.h"
using namespace Emwd::kozaiku;
// Header => start
$header
// Header => end
bool Kozaiku_Template_Autogen::display_${basename}(void* stash)
{
// Init => strt
	$init
// Init => end
// Source => start
	$source
// Source => end
	return true;
}

extern "C" int kozaiku_display_${basename}(void* stash)
{
	Emwd::kozaiku::Kozaiku_Template_Autogen tpl;
	tpl.display_${basename}(stash);
	return 1;
}

EOS

	my $sourceFilename = "Kozaiku_Template_Autogen_".$basename.".cpp";
	open(OUT, '> ', $sourceFilename) or die $! ." : ". $sourceFilename;
	print OUT $generatedSource;
	close(OUT);
	print $sourceFilename ." created.\n";

	$memberFunction .= "	bool display_${basename}(void *stash);\n";
}

my $headerSource = <<"EOS";
// vim:set noexpandtab sts=0 ts=4 sw=4 ft=cpp fenc=utf-8 ff=unix:
//==========================================================
// DO NOT EDIT. THIS FILE IS GENERATED BY Kozaiku.pl
//==========================================================
#ifndef EMWD_KOZAIKU_TEMPLATE_AUTOGEN_H_
#define EMWD_KOZAIKU_TEMPLATE_AUTOGEN_H_

#include <string>

namespace Emwd { namespace kozaiku {

class Kozaiku_Template_Autogen
{
public:
$memberFunction
};

} }
#endif /* EMWD_KOZAIKU_TEMPLATE_AUTOGEN_H_ */
EOS

my $headerFilename = "Kozaiku_Template_Autogen.h";
open(OUT, '> ', $headerFilename) or die $! ." : ". $headerFilename;
print OUT $headerSource;
close(OUT);

print $headerFilename ." created.\n";
print "Finish.\n";


__END__
<?header
?>

<?init
std::string *str = (std::string *)stash;
?>

<html>

<?c++
str->assign("test tes test");
?>

<?=
?>

</html>
